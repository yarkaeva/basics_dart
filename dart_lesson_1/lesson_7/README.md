# Классы. Cкрытые интерфейсы/implements
Наследование в языке Dart имеет важное ограничение: **мы не можем наследовать класс сразу от нескольких классов**

Для решения этой проблемы в Dart применяется **реализация интерфейсов**. При этом важно понимать, что *интерфейс - это не отдельная сущность*, как в некоторых языках программирования (например, тип interface в C# или Java), а тот же *класс.* То есть класс в Dart одновременно выступает в роли интерфейса, и другой класс может реализовать данный интерфейс.


Принцип работы:
Если класс-интерфейс определяет какие-нибудь поля и методы, то класс, реализующий данный интерфейс, **должен** также определить эти поля и методы.

Для реализации интерфейсов применяется оператор `implements`.

## Наследование классов vs реализация интерфейсов
**При наследовании** производный класс 
- **не обязан определять те же поля и методы, которые есть в базовом классе** (за исключением абстрактных методов). 
- Если базовом классе определяется конструктор, то **производный класс обязан определить свой конструктор, при котором вызывается конструктор базового класса**.
- В производном классе мы можем обращаться к реализации базового класса с помощью ключевого слова `super`.
- **Не** поддерживается множественное наследование.

**При реализации интерфейса** производный класс 
- **должен определить все поля и методы, которые определены в классе интерфейса.** 
- Если в базовом есть конструктор, то производный класс **НЕ обязан определять свой конструктор**.
- В производном классе мы **НЕ можем** обращаться к методам реализованного интерфейса с помощью ключевого слова `super`. 
- Поддерживается множественная реализация интерфейсов.


В примере ниже мы в классах `Cup, Plate, Table` реализовали интерфейс класса `Weightable` (у каждого есть свойство `weight`). Если мы захоти получить их общий вес, то положим их в список, зададим переменную `totalWeight` и с помощью цикла `for in` будет добавлять в `totalWeight` значение веса каждого объекта.
Это разные объекты, поэтому они попытаются найти одного общего 
предка, но тк не наследуются от какого-то общего класса, то этот предок 
будет Object. Тот в свою очередь не имеет свойства weight. Мы получим ошибку. 

Классы имплементируют интерфейс Weightable, поэтому мы можем обобщить их под типом этого интерфейса и всё заработает.

```dart
void main() {
    final listOfSome = <Weightable>[Cup(18), Plate(11), Table(56)];
    double totalWeight = 0;
    for (final element in listOfSome) {
        totalWeight += element.weight;
    }

    print(totalWeight); //85.0
} 


  abstract class Weightable {
  Weightable(this.weight);

  final double weight;
}


class Cup implements Weightable, Dishable, Indetinfirable {
  Cup(this.weight);

  final double weight;
  }
}

class Plate implements Weightable, Dishable, Indetinfirable {
  Plate( this.weight);

  final double weight;
 
}

class Table implements Weightable {
  Table(this.weight);

  final double weight;
}
```
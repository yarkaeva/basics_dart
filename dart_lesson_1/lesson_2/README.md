# Функции
Функции представляют собой блок кода, записывающий набор операций. Функцию можно многократно вызывать, что скоращает количество напиcанного кода.

По умолчанию среда выполняет только функцию `main`. Поэтому, чтобы выполнить функцию, ее необходимо вызвать в функции `main`.


[тип возвращаемого значения] название функции(параметры) {
    тело функции;
    }
Если что-то возвращаем, то в теле функции необходимо прописать`return`.
Можно ничего не возвращать, тогда в начале(в типе возвращаемого значения) пишем `void`.

Параметров может быть сколько угодно, но возвращаемое значение всегда одно.
Количество передаваемых аргументов должно соответствовать количеству параметров. Кроме того между типами аргументов и типами параметров должно быть соответствие.

*Например*, в функции `sum` мы прописали параметры `a` и `b` с типом `int`, то есть функция должна принять два аргументы с типом `int`.

```dart
void main(List<String> args) {
  print(sum(4, 7));
}

int sum(int a, int b) {
  final result = a + b;
  return result;
}
```
Если функция состоит из одного выражения, то ее можно сократить следующим образом:
[тип возвращаемого значения] название функции(параметры) = > выполняемая операция
```dart
int sum(int a, int b) => a + b;
```


## Области видимости
Есть глобальная область видимости (находится на самом высоком уровне) и локальные. 
Всё, что ты объявляешь в вышестоящей области видимости будет доступно в нижестоящей области видимости. 
Любая локальная область видимости может создать внутри себя переменную с таким же именем как в той, что выше неё самой, и работать со своей переменной. Вложенные в неё области видимости будут работать уже с её переменной.

*Например*,
```dart
int globalA = 0;

void main(List<String> args) {
  globalA = 4;//переопределили переменную
  void sum2() {
    globalA = globalA + 5;
    print(globalA);
  }
  sum2(); //выведет 9
}
```
**!**нужно помнить, что функции наследуют переменные по области видимости, где они объявлены, а из той, где они вызываются. 
*Например*,
``` dart
int a = 4;

void main(List<String> args) {
  int a = 0;
  final result = sum4(6); //вызов функции
  print(result);//выведет не 6, а 10
}
```
Функции могут принимать другие функции

```dart
int timesTwo(int x) {
  return x * 2;
}

int timesFour(int x) => timesTwo(timesTwo(x));

// функции - это объекты
int runTwice(int x, int Function(int) f) {
  for (var i = 0; i < 2; i++) {
    x = f(x);
  }
  return x;
}

void main() {
  print('4 times two is ${timesTwo(4)}');
  print('4 times four is ${timesFour(4)}');
  print('2 x 2 x 2 is ${runTwice(2, timesTwo)}');
}
```

# Операторы ветвления
Условные конструкции позволяют в зависимости от определенного условий направить работу программы по одному из путей.

## if/else
Выражение `if/else` проверяет истинность некоторого условия и в зависимости от результатов проверки выполняет определенный код. С помощью выражения `else if`, мы можем обрабатывать дополнительные условия.

```dart
final a = 3;
final b = 3;

  if (a < b) {
    print('a меньше b');
  } else if (a > b) {
    print('a больше b');
  } else {
    print('a и b равны');
  }
  ```
## switch/case
После ключевого слова `switch` в скобках идет сравниваемое выражение. Значение этого выражения последовательно сравнивается со значениями, помещенными после оператора `сase`. И если совпадение будет найдено, то будет выполняться определенный блок `сase`.
в конце блока сase должен идти оператор break, либо один из следующих операторов: `continue, throw, return`. Если мы хотим также обработать ситуацию, когда совпадения не будет найдено, то можно добавить блок `default`.

```dart
int num2 = 4;
switch (num2) {
    case 6:
      print("Угадал");
      break;
    case 3:
      print("слишком много");
      break;
    default:
      print("хз хз");
  }
  ```